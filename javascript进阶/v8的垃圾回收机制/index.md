## V8 引擎垃圾内存回收

在其他编程语言中，如`Java/go`对内存的使用是没有限制的，但是`JS`不一样，`V8`只能使用系统的一部分内存：在 64 位的系统下面，V8 最多只能分配`1.4G`,在 32 位系统中，最多只能分配`0.7G`.如果是在前端`client`需要的内存需求并不大，但是在后端`nodeJS`中，想要读取一个超过`1.4G`的文件，那就没办法操作。

**栈内存**
都知道在`ESP`指针在栈顶下移的时候，也就是代码发生上下文切换，栈顶的空间就会被自动回收

**堆内存**
所有对象类型的变量在`JS`中都是存放在堆内存里面的。当创建一个对象，只要进行了赋值操作，`V8`就在堆内分配相应的内存。可以一直创建直到堆内存达到上限

**那为什么 V8 要设置上限，既然机器有足够大的内存。**
有两个原因：

1. JS 单线程的执行机制
2. JS 垃圾回收机制的限制

---

`JS`是单线程，这意味着一旦进入到垃圾回收，那么其他运行的逻辑都要暂停下来；垃圾回收是一个非常耗时的操作。`V8`官方描述：

> 以`1.5G`垃圾回收堆内存为例，`V8`做一次小的垃圾回收需要`50ms`以上，做一次非增量式的垃圾回收甚至要`1s`以上

所以如果内存非常大的话，垃圾清理的时候耗时非常久，因为单线程，当前`JS`代码会一直没有响应，造成应用卡顿，当前的应用的性能和响应能力急剧下降。所以`V8`选择了一个粗暴的方法，**限制堆的内存**。
当然，也能调整内存的限制，配置的命令是：

```
// 老生代
node --max-old-space-size=2048 xxx.js

// 新生代
node --max-new-space-size=2048 xxx.js
```

### 新生代内存回收

`V8`把内存分成了两部分进行处理-新生代内存和老生代内存，顾名思义，新生代就说临时分配的内存，存活时间短，老生代是常驻内存，存活时间长。`V8`的堆内存就相当于两个内存之和。

![新生代和老生代内存分配](https://github.com/zengwmFE/frontEnd-base/blob/master/image/heap.png)

两种不同得内存，`v8`采用了不同得回收策略，来针对不同得场景做针对性优化。

### 老生代内存回收
