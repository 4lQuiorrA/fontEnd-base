## V8 引擎垃圾内存回收

在其他编程语言中，如`Java/go`对内存的使用是没有限制的，但是`JS`不一样，`V8`只能使用系统的一部分内存：在 64 位的系统下面，V8 最多只能分配`1.4G`,在 32 位系统中，最多只能分配`0.7G`.如果是在前端`client`需要的内存需求并不大，但是在后端`nodeJS`中，想要读取一个超过`1.4G`的文件，那就没办法操作。

**栈内存**
都知道在`ESP`指针在栈顶下移的时候，也就是代码发生上下文切换，栈顶的空间就会被自动回收

**堆内存**
所有对象类型的变量在`JS`中都是存放在堆内存里面的。当创建一个对象，只要进行了赋值操作，`V8`就在堆内分配相应的内存。可以一直创建直到堆内存达到上限

**那为什么 V8 要设置上限，既然机器有足够大的内存。**
有两个原因：

1. JS 单线程的执行机制
2. JS 垃圾回收机制的限制

---

`JS`是单线程，这意味着一旦进入到垃圾回收，那么其他运行的逻辑都要暂停下来；垃圾回收是一个非常耗时的操作。`V8`官方描述：

> 以`1.5G`垃圾回收堆内存为例，`V8`做一次小的垃圾回收需要`50ms`以上，做一次非增量式的垃圾回收甚至要`1s`以上

所以如果内存非常大的话，垃圾清理的时候耗时非常久，因为单线程，当前`JS`代码会一直没有响应，造成应用卡顿，当前的应用的性能和响应能力急剧下降。所以`V8`选择了一个粗暴的方法，**限制堆的内存**。
当然，也能调整内存的限制，配置的命令是：

```
// 老生代
node --max-old-space-size=2048 xxx.js

// 新生代
node --max-new-space-size=2048 xxx.js
```

### 新生代内存回收

`V8`把内存分成了两部分进行处理-新生代内存和老生代内存，顾名思义，新生代就说临时分配的内存，存活时间短，老生代是常驻内存，存活时间长。`V8`的堆内存就相当于两个内存之和。

![新生代和老生代内存分配](https://github.com/zengwmFE/frontEnd-base/blob/master/image/heap.png)

两种不同得内存，`v8`采用了不同得回收策略，来针对不同得场景做针对性优化。

1. 新生代

> 新生代系统分配得内存:`64位为32MB`,`32位为16GB`,新生代内得变量，往往都是一些用完就会被清除得变量.

将新生代的内存空间分成 2 块:`from`和`to`

- from 代表正在使用的内存
- to 代表目前闲置的内存

1. 在进行垃圾回收的时候，`V8`会将`from`的所有内存都检查一遍，如果是存活对象，那么复制到`To`内存中（在`to`内存中按照顺序从头放置的），如果是非存活的对象直接回收即可
2. 当`from`内的所有对象都检查完之后，`from`和`to`角色对换，`from`成为了被闲置的，`to`成为了正在使用的内存
3. 重复第一步的步骤，检查使用中的内存空间

Q1：直接将内存中的非存活的对象清除，不是更快吗？那为什么还将存活的对象移往`to`空间呢？

A1: 堆的内存分配是连续的，对象的创建，往往会占据一部分比较大的空间，如果该对象变成了非存活的对象被清除后，那么这一块的空间就被空出来了，这样多了几次之后，整个内存空间可能出现不是连续的情况，然后当我们需要声明一个较大的对象的时候，这个新的对象无法放进已经空出来的部分空间，所有他需要重新找一块连续的内存空间。

![](https://github.com/zengwmFE/frontEnd-base/blob/master/image/suipiankongjian.png)

绿色的区域就是未被分配的空间，白色的是已经被分配的，存活的对象。这样一个空间被称为：`内存碎片`。将存活空间`from`移动到`to`，并按照有序顺序排列好，而进行这个过程的操作，被称为:`Scanvenge算法（拾荒者算法）`

#### Scanvenge 算法

`Scanvenge`算法通过牺牲空间来获取比较适合生命周期比较短的新生代，`Scanvenge`算法只能使用一半的新生代的内存空间。
当新生代的对象，进行了很多次的检查仍然存在的话，这个变量就会被放到老生代中，而这种现象被称为：`晋升`

晋升的条件(什么时候能够触发晋升):

1. 已经经历过一次`Scanvenge`算法整理
2. To(闲置)空间的内存超过`25%`

### 老生代内存回收

在老生代的内存大小是非常大的，如果在使用`Scanvenge`算法，就非常消耗性能了。所以要使用其他的算法。
**老生代的内存清除一般分为：标记阶段和清除阶段**

#### 标记阶段

> 首先他会遍历堆里面所有的对象，然后在对象上增加**标记**
