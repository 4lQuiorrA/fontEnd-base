## 描述一段 JS 代码在 V8 中的执行过程

首先：机器是没办法直接读懂`JS`代码想要表达的内容是什么！机器只能理解特定的字节码。所以说要让`JS`逻辑能在机器中运行，必须将`JS`代码转换成`机器码`.`JS`是一门**解释器语言**，在`JS`执行的过程中，会执行：

1. 通过词法分析(`Tokens`)/语法分析来生成`AST`
2. 生成字节码
3. 字节码解释执行

### 生成`AST`

生成 AST 一般包括了 2 个过程

1. 词法分析
2. 语法分析

#### 词法分析（分词）

这个过程的任务是将代码，分解成一个 tokens 的类数组形式，例子

```
function foo(a,b){
  return a+b
}
```

在这里就可以发现被分解成了这么几块：

```
['function','foo','a','b','return','a','+','b']
```

#### 语法分析

```
可以大概的去创建一个这样的白话的AST
['Function 定义'->['foo函数名','params'->['a params 第一个','b params第二个'],
'{} 函数定义块block'->['return 返回statement'->['a 表达式','+ 操作符','b 表达式']],]
```

根据这个数组，可以构建出一个大概的 AST
![](https://github.com/zengwmFE/frontEnd-base/blob/master/image/ASTbyself.png)

### 生成字节码

`JS`是一个解释性语言，所以肯定离不开`解释器`,`V8`得解释器（`Ignition`(点火装置，哈哈哈)）来生成字节码，但是机器只能执行得是`机器码`。由于机器码要比字节码体积更大，`V8`早期采取了直接将`AST`转化成`机器码`，导致了大量内存被占用。所以当前`V8`使用得是将`JS`转换成`字节码`，然后再通过**解释器去逐行执行字节码，这样避免了大量代码生成 2 进制文件，这样也大大得降低了内存得压力**。

### 字节码解释执行

在字节码执行得过程中，如果发现某一部分代码重复出现，那么`V8`就会将这一部分代码判定成`热点代码（hotSpot）`，`V8`就会通过编译器`turbofan(涡轮风扇。。。。哈哈哈哈)`转换成机器码，并保存起来。在这样的执行机制下，整个代码得执行效率将会越来越高，因为越来越多得字节码被标志成热点代码(`hotspot`),当遇到相同得字节码时，就会直接执行相应得机器码，就不会再去转换成机器码了。这种字节码和编译器和解释器相结合，被称为`JIT`
