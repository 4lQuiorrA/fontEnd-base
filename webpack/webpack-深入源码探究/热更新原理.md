## 热模块更新原理
### 热模块更新的方法
> `Hot Module Replacement`简称`HMR`，可以通过不刷新整个页面，只修改改变了的模块。`HMR`作为`webpack`内置的功能，可以通过：1. 命令行设置--hot来实现；2. 通过`HotModuleReplacementPlugin`来实现。

### 启动webpack-dev-server
#### 根据`webpack`内的`package.json`中:
```
"bin": {
    "webpack-dev-server": "bin/webpack-dev-server.js"
  },
```
可以知道webpack的起始文件:`bin/webpack-dev-server.js`

#### 实例化webpack，启动编译的过程

```
compiler = webpack(config);

```
#### 启动服务

```
// 启动服务
server = new Server(compiler, options, log);
serverData.server = server;

 if (options.socket) {
    server.listeningApp.on('error', (e) => {
      if (e.code === 'EADDRINUSE') {
        const client``Socket = new net.Socket();

        clientSocket.on('error', (err) => {
          if (err.code === 'ECONNREFUSED') {
            // No other server listening on this socket so it can be safely removed
            fs.unlinkSync(options.socket);

            server.listen(options.socket, options.host, (error) => {
              if (error) {
                throw error;
              }
            });
          }
        });

        clientSocket.connect({ path: options.socket }, () => {
          throw new Error('This socket is already used');
        });
      }
    });

    server.listen(options.socket, options.host, (err) => {...});
  } else {
    server.listen(options.port, options.host, (err) => {
      if (err) {
        throw err;
      }
    });
  }
```

#### 本地服务代码
```
// '../lib/Server'
class Server{
  constructor(){
    //
    this.setupHooks();
    this.setupApp();
    // 每次初始化之前都要先把原有的进程给杀掉
    killable(this.listeningApp);
    ...
    // 创建服务
     this.createServer();
  }
}
```
1. 第一步：注册`hooks`
```
  setupHooks() {
    const addHooks = (compiler) => {
      const { compile, invalid, done } = compiler.hooks;

      compile.tap('webpack-dev-server', invalidPlugin);
      invalid.tap('webpack-dev-server', invalidPlugin);
      done.tap('webpack-dev-server', (stats) => {
        this._sendStats(this.sockets, this.getStats(stats));
        this._stats = stats;
      });
    };

    if (this.compiler.compilers) {
      this.compiler.compilers.forEach(addHooks);
    } else {
      addHooks(this.compiler);
    }
  }
```
2. 第二步，初始化`express`
```
  setupApp() {
    this.app = new express();
  }

```
3. 创建服务，分为两步，
  - 先创建了本地`server`,回调继续创建一个`websocket服务`，已实现当本地代码发生改变了，能够第一时间将更新后的代码推送到浏览器了

```
  // 然后在实例化server调用listen，在webpack-dev-server文件中调用
  
  listen(port, hostname, fn) {
    this.hostname = hostname;

    return this.listeningApp.listen(port, hostname, (err) => {
      this.createSocketServer();

      if (this.options.bonjour) {
        runBonjour(this.options);
      }

      this.showStatus();

      if (fn) {
        fn.call(this.listeningApp, err);
      }

      if (typeof this.options.onListening === 'function') {
        this.options.onListening(this);
      }
    });
  }
  // 1. 先执行了createServer创建了服务实例
  createServer() {
      this.listeningApp = http.createServer(this.app);
  }
```


