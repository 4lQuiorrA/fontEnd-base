本地书写的代码，经过`build`之后就会生成`render`，然后上传到服务器之后，经过浏览器拉取就会执行`render`里面的逻辑，`with(this)`，也就是如果我们在页面中获取了`text`这个动态数据，就会有获取到`this.text`的这个值，一开始这个值就通过了`Object.defineProperty`给监听，而就会把我们要怎么样去渲染(`{对应的数据:要做的事情}`的`key-value`关系)的过程，通过`watcher`添加到`Dep`（联系本）中记录下来，等到下一次更新，数据发生改变的时候，就可以通过之前保存好的`dep`中的渲染过程，来生成新的`vnode`.

也就是说`setter`触发消息到`Watcher`，`watcher`帮忙告诉`Directive`更新`DOM`，`DOM`中修改了数据也会通知给`Watcher`，`watcher`帮忙修改数据

## 总结

### vue1

在 vue1 的时候，由于一个指令（`directive`）对应了一个`watcher`,这样的话，就根本不需要`dom diff`的参与，因为我每次改变都能知道每个指令对应要修改的地方。所以不需要`dom diff`的参与，但是问题也就出来了，这样存放在内存中的`watcher`也就开始变多了,就

### vue2

`vue2`为了解决内存变多之后，就会经常卡顿，为了解决这个问题，`vue2`更改了就更改一个`render`函数对应了一个`watcher`,这样的话，同时操作的组件个数也可以随时都知道，但是这样的话，当`watcher`知道要更新的时候，就会通知`render`函数改变，这个时候，组件不知道哪里改变了，这个时候就要进行组件`dom diff`

### 对比于 react

因为 `react`没有维护一套双向数据，所以他不知道每个数据发生改变的时候，需要对应改变那个组件，没有办法他就需要做全局的`dom diff` ,这也就导致了`js`阻塞的情况，
