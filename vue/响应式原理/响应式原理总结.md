1. 本地书写的代码，经过`build`之后就会生成`render`（如果通过执行`Vnode`）

2. 接着触发响应式处理
    1. 数据处理成为响应式数据`__ob__`，
    2. 然后通过了`Object.defineProperty`监听，
    3. 然后将**数据以及订阅数据的那个数据的`key`对应的`render`操作**(而这东西也就是`Watcher`)保存到`Dep`
    4. 也就是说当改变了数据的时候，就会触发`setter`，然后调用`Dep.notify()`来通知对应的订阅数据的相关数据的操作，来重新获取新的数据，重新执行`render`.
    5. 如果是获取数据的时候，就会触发`getter`,然后触发`Object.definedProperty`的`getter`，执行了`dep.depend()`,也就是`Dep.target.addDep(this)`，将`Watcher`添加进了`Dep`，而在`vue2`中的一个组件对应了一个`Watcher`


3. 等浏览器将代码拉下来执行之后，就会执行`render`，然后给每个组件都增加`new Watcher(){Dep.target}`,然后当`render`中获取了某个数据的时候就会触发`get`操作，就会渲染出来。
4. 修改数据`set`,然后就会拿到对应修改的响应式数据维护的依赖，然后触发`Dep.notify()`，去发布修改

## 总结

### vue1

在 vue1 的时候，由于一个指令（`directive`）对应了一个`watcher`,这样的话，就根本不需要`dom diff`的参与，因为我每次改变都能知道每个指令对应要修改的地方。所以不需要`dom diff`的参与，但是问题也就出来了，这样存放在内存中的`watcher`也就开始变多了,就

### vue2

`vue2`为了解决内存变多之后，就会经常卡顿，为了解决这个问题，`vue2`更改了就更改一个`render`函数对应了一个`watcher`,这样的话，同时操作的组件个数也可以随时都知道，但是这样的话，当`watcher`知道要更新的时候，就会通知`render`函数改变，这个时候，组件不知道哪里改变了，这个时候就要进行组件`dom diff`

### 对比于 react

因为 `react`没有维护一套双向数据，所以他不知道每个数据发生改变的时候，需要对应改变那个组件，没有办法他就需要做全局的`dom diff` ,这也就导致了`js`阻塞的情况，
