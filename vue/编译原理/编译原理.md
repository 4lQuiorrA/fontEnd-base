## 编译原理

### vue 基本转换过程

1. 找到对应的`template`,`script`,`style`

```
<template>
  <div id="app" >
    <div>{{ msg }}</div>
    <span>测试</span>
  </div>
</template>
```

2. 将`template`转换成 render

```
function render() {
  with(this) {
    return _c('div', {
      attrs: {
        "id": "app"
      }
    }, [_c('div', [_v(_s(msg))]), _c('span', [_v("测试")])])
  }
}
```

3. 当执行了`render`函数之后会转换成`vnode`。然后根据`vnode`渲染成真实`dom`

在模板到真实 DOM 渲染的过程中，中间有一个环节是把模板编译成`render`函数，这个过程把他称为编译
正常来说，vue 提供了两种编写方法：`render`函数，使用模板。在大部分开发的情况下都会使用模板来开发，也更简洁一点

#### 在线编译和离线编译

离线编译

> 我们通过`build`构建的过程被称为`离线编译`

在线编译

> 就是当我们通过`vue-loader`获取到的`template`,会是一个字符串的过程(看下文代码展示),这样的话，在浏览器或者`js`肯定不能直接识别出来这个东西，所以这个时候就要通过在线编译，通过`js`将这段代码编译，将他转换成`render`这类代码

```
Vue.component('button-counter',{
  data: function(){
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">You click me {{count}}</button>'
})
```

#### react 和 vue template 的区别

> `vue template`属于编译时优化，需要用户按照既定规则来书写

### 源码分析

vue 提供了两个版本：

1. 一个是 Runtime+Compiler 的,包含编译代码的，可以把编译过程放在运行时做，**即在线编译所使用的包**
2. 一个是 Runtimeonly，不包含编译代码，需要借助 webpack 的 vue-loader 实现编译成 render 函数，**即离线编译所使用的包**

### 编译入口

`$mount`代码在`src\platforms\web\entry-runtime-with-compiler.js`：

```
const mount = Vue.prototype.$mount; // 保存一份原来的$mount保存
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el);
  const options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template;
    if (template) {
      if (typeof template === "string") {
        if (template.charAt(0) === "#") {
          template = idToTemplate(template);
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      const { render, staticRenderFns } = compileToFunctions(
        template,
        {
          outputSourceRange: process.env.NODE_ENV !== "production",
          shouldDecodeNewlines,
          shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments,
        },
        this
      );
      options.render = render;
      options.staticRenderFns = staticRenderFns;
    }
  }
  return mount.call(this, el, hydrating);
};
```

这里可以看到官方注释是写到`resolve template/el and convert to render function`,将`template/el`转换成`render`函数，通过官方文档关于`render`的解释

```
(createElement: () => VNode) => VNode

```

-
- 字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode
- Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。

由源码可以知道解析的优先级为:`render->template->el`

而在这里面，编译的入口就是：

```
const { render, staticRenderFns } = compileToFunctions(
        template,
        {
          outputSourceRange: process.env.NODE_ENV !== "production",
          shouldDecodeNewlines,
          shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments,
        },
        this
      );
      options.render = render;
      options.staticRenderFns = staticRenderFns;
```

`compileToFunctions`是最关键的点：就是把模板`template`编译生成`render`和`staticRenderFns`，它的定义在`src\platforms\web\compiler\index.js`:

```
const { compile, compileToFunctions } = createCompiler(baseOptions)

export { compile, compileToFunctions }
```

可以看到`compileToFunctions`是作为`createCompiler`的返回值，`createCompiler`接收一个编译参数：

```
export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
```

在经过`parse`成`ast`,然后`optimize`优化，最后生成我们需要的`code`,也就是前面提到的：

```
function render() {
  with(this) {
    return _c('div', {
      attrs: {
        "id": "app"
      }
    }, [_c('div', [_v(_s(msg))]), _c('span', [_v("测试")])])
  }
}
```

在这里`createCompiler`是作为`createCompilerCreator`的返回值：

```
export function createCompilerCreator (baseCompile: Function): Function {
  return function createCompiler (baseOptions: CompilerOptions) {
    function compile (
      template: string,
      options?: CompilerOptions
    ): CompiledResult {
      const finalOptions = Object.create(baseOptions)
      const errors = []
      const tips = []

      let warn = (msg, range, tip) => {
        (tip ? tips : errors).push(msg)
      }

      if (options) {
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules)
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          )
        }
        // copy other options
        for (const key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key]
          }
        }
      }

      finalOptions.warn = warn

      const compiled = baseCompile(template.trim(), finalOptions)
      if (process.env.NODE_ENV !== 'production') {
        detectErrors(compiled.ast, warn)
      }
      compiled.errors = errors
      compiled.tips = tips
      return compiled
    }

    return {
      compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}
```

`createCompilerCreator`接收一个函数，同时返回了一个`createCompiler`,而在`createCompiler`返回了一个对象分别为：`compile`,`compileToFunctions`,而这个对应得就是`$mount`中调用得了

```

export function createCompileToFunctionFn (compile: Function): Function {
  const cache = Object.create(null)

  return function compileToFunctions (
    template: string,
    options?: CompilerOptions,
    vm?: Component
  ): CompiledFunctionResult {
    options = extend({}, options)
    const warn = options.warn || baseWarn
    delete options.warn
    // check cache
    const key = options.delimiters
      ? String(options.delimiters) + template
      : template
    if (cache[key]) {
      return cache[key]
    }

    // compile
    const compiled = compile(template, options)

    // turn code into functions
    const res = {}
    const fnGenErrors = []
    res.render = createFunction(compiled.render, fnGenErrors)
    res.staticRenderFns = compiled.staticRenderFns.map(code => {
      return createFunction(code, fnGenErrors)
    })

    return (cache[key] = res)
  }
}
```

`createCompileToFunctionFn`得执行，返回了一个`compileToFunctions`函数，接收了`template`,`options`,`vm`三个参数，而在里面最关键得就是`const compiled = compile(template, options)`将`template`进行编译，而`compile`这个函数是作为执行`createCompileToFunctionFn`得函数传入得：

```
function compile (
      template: string,
      options?: CompilerOptions
    ): CompiledResult {
      const finalOptions = Object.create(baseOptions)
      const errors = []
      const tips = []

      let warn = (msg, range, tip) => {
        (tip ? tips : errors).push(msg)
      }

      if (options) {
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules)
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          )
        }
        // copy other options
        for (const key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key]
          }
        }
      }

      finalOptions.warn = warn

      const compiled = baseCompile(template.trim(), finalOptions)
      compiled.errors = errors
      compiled.tips = tips
      return compiled
    }
```

那么相当于`baseCompile`这个函数得返回结果

```
function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
}
```

那就是相当于执行了

1. 解析模板字符串生成 AST

```
 const ast = parse(template.trim(), options)
```

2. 对 AST 进行优化

```
 if (options.optimize !== false) {
    optimize(ast, options)
  }
```

3. 生成

```
const code = generate(ast, options)
```
