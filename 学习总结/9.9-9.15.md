### js

#### 1.1 script元素
script属性：
1. async:可选，表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本，只对外部脚本文件有效
2. charset:可选。表示通过src属性指定的代码的字符集。但由于大部分浏览器都会忽略他的值
3. defer可选。表示脚本可以延迟到文档完全解析和显示再执行。只对外部脚本文件有效。
4. language 原来用于表示编写代码使用的脚本语言，已经废弃了
5. src 可选，表示要执行代码的外部文件
6. type 表示编写代码使用的脚本语言的内容类型

**js脚本的延迟加载**
1. 同步加载
> 又称阻塞模式，就是直接将script标签直接写到head标签里面，这样做在页面进行解释的时候，因为先开始解析script脚本，这时候，页面会被阻塞需要先去执行js脚本。而且当页面需要获取以后的`dom`元素的时候，会出现获取不到元素的时候，所以一般建议是将script标签放到body的最后面

2. 异步加载
> 有的时候，一些js资源需要先加载执行，而且同时页面也不能被阻塞住，所以的话这个时候需要用到异步加载：既能是页面正常渲染，也能加载必要的js文件‘

- defer属性（XHTML4.0） - 延迟脚本

> 这个属性的用途是表明脚本在执行时不会影响页面的构造，也就是说脚本会被延迟到整个页面都解析完毕后再运行

- async属性（HTML5.0）- 异步脚本
> script标签增加了这个属性，这个属性，不会阻塞代码的执行，浏览器渲染页面的同时，也会去下载脚本并且执行，但是当多个脚本被下载下来的时候，因为脚本被下载下来的时间不一定，所以执行的时间也往往会不一定，也许a先定义，b后定义，但是b却比a要先执行

但是如果脚本文件之间没有引用关系，可以直接执行完成，这个时候`async`就能够优先执行了，**异步脚本一定会在页面的load事件前执行**

`defer`和`async`的比较
- 相同点
    1. 加载文件时不会阻塞文件的执行
    2. 对于内部js执行不产生任何副作用
    3. 在加了这两个属性里面，都不要修改DOM
- 不同点
    1. 页面解析不能等待async属性的脚本，async属性的脚本，当下载下来之后会直接执行，同时他会在页面的onload事件之前执行
    2. defer会在页面渲染完成之后才会被调用

---
- 动态创建DOM的方法

```
window.addEventListener("load",function(){
    var element = document.createElement('script');
    element.src = "defer.js";
    document.body.appendChild(element)
})
```

- jquery中的getScript

- setTimeout延迟加载js方法

- 将脚本放到body的最后面


**潜入代码与外部文件**
外部文件的好处
- 可维护性：这样可以将脚本文件统一的放到同一个文件下，这样容易维护，同时可以不触及HTML的情况下
- 可缓存：浏览器能够根据具体设置缓存连接的所有JavaScript文件。
- 适应于未来


**noscript**
早期浏览器都面临一个问题，即当浏览器不支持Javascript时，如何让页面平稳地退化，对这种问题的最终解决方案是创造一个`noscript`，用以不支持JavaScript的浏览器显示替代的内容。

```
<noscript>
<p>本页面需要浏览器支持Javascript</p>
</noscript>
```


#### defineProperty
1. 一旦使用`Object.defineProperty`给对象添加属性，那么如果不设置值的属性特征，那么`configurable`和`enumerable`、`writable`这些值都是默认的false
2. Object.defineProperty方法会直接在一个对象上定义一个新属性或者修改一个对象的现象，并**返回这个对象**
3. 除了可以定义新属性设置特性，也可以给已有的属性设置特性
4. 当使用getter和setter方法，不可以使用`writable`和`value`这两个属性

#### 元编程
1. Reflect用于直接调用Object方法如`Reflect.assign`。
2. Proxy用于自定义的对象的行为如修改set和get
3. Symbol,Reflect和Proxy是属于ES6元编程范畴，能介入对象的底层操作进行的过程。

#### HTTP首部
首先要知道：HTTP报文的结构：报文首部+空行（CR+LF）+报文主体
**报文首部**
在客户端和服务器处理时起至关重要作用的信息几乎都在这里
**报文主体**
所需要的用户和资源信息都在这边

HTTP请求报文：请求方法（method）、uri（/index.html）、HTTP版本号（http1.1）HTTP首部字段

HTTP响应报文：HTTP报文由HTTP版本，状态码（数字+短语 200 success）HTTP首部字段

**HTTP首部字段**
为了给浏览器和服务器提高报文主体大小、所使用的语言和认证信息等内容
1. 通用首部字段
2. 请求首部字段
3. 响应首部字段
4. 实体首部字段


**常用的通用首部字段**
- Cache-control
通过指定首部字段Cache-control的指令，就能操作缓存的工作机制
可以使用多个指令，用`,`分割

    1. no-cache 强制向源服务器再次验证
    2. no-store 不缓存请求和响应的任何内容
    3. max-age  响应的最大缓存时间 使用了必定要指定内容
    4. max-stale 表示能接收过期时间在这个时间以内的资源
    5. min-fresh 只接受在规定时间内更新过的资源 使用时一定要指定时间
    6. no-transform 代理不可更改的媒体类型
    7. only-if-cached 仅支持从缓存中获取资源
    8. cache-extension 