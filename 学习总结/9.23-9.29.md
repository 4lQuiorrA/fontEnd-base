### 执行环境（执行上下文）（execution Context）

原文地址：http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/

执行环境可能是以下3种情况：

- 全局code(Global code)	代码第一次执行的默认环境
- 函数code(Function code)  进入函数体进行执行
- Eval code   在eval内部函数执行

🌰

```
// global context
var sayHello = 'Hello'
function person(){
	var first = 'David',
	last = 'Shariff';
	function firstName(){
		return first
	}
	function lastName(){
	return last
	}
	
	alert(firstName()+'---'+lastName());
}
```

这有1个`global context`和3个`function context`:`person`、`firstName`、`lastName`

在一段代码中，可以拥有多个`function context`，但是有且只有一个`global context`。每当有一个函数被执行了，就会创建一个新的`context`，它会生成一个私有作用域，在这个`context`内的所有变量和函数都无法被外部的内容所直接访问到。

#### 执行上下文栈

> 浏览器中的`javascript`解析器是单线程的。就是说，在浏览器中，同一时间只能做一件事，而其他内容只能在`Execution Stack(执行栈)`中排队

```
// global context
var a = 1;
function parent(){
	var a = 2;
	function childrenPre(){
		var a = 3;
		function childLast(){
			var a = 4;
		}
		childLast();
	}
	childRenPre();
}
parent();
```

可以用这个程序来解释一下单线程的抽象概念

![](https://github.com/4lQuiorrA/frontEnd-base/blob/master/image/zhixingshangxiawen.png)

1. 当代码开始执行的时候，会默认进入`global context`全局执行上下文，然后将全局压入栈底
2. 然后`parent`函数执行，生成一个`execution context`,然后将当前`parent -execution context`继续往执行栈上压
3. 继续执行`childrenPre`，继续生成一个`execution context`，将其压入栈中
4. 执行`childLast`，生成一个`execution context`,压入栈中，之后发现没有再可执行的函数了。
5. 这个时候就开始将当前函数执行出栈操作了，当一个函数执行完之后，就会将执行完的执行上下文弹出栈，指向当前执行函数的指针就会开始往下一块的执行上下文移动

总结：

1. 单线程
2. 同步执行
3. 有且只有1个`global context`
4. 无限制的函数`context`
5. 每次函数调用都会产生一个新的`execution context`

---

#### execution context的一些细节

在javaScript解释器内部，每次调用`execution context`都有两个过程：

1. 创建过程
   - 创建`Scope Chain`
   - 创建变量、函数和参数
   - 确定`this`
2. 代码执行过程
   - 变量赋值、引用函数和解释/执行代码

**每个`execution context`在js的概念上都可以用一个对象来表示：**

```
executionContextObj = {
	"scope chain": {/*this.VariableObject+ 所有外层作用域的VariableObject*/},
	variableObject: {/*函数的形参，变量，以及函数内部出现的一些函数定义*/},
	"this":{}
}
```

> 整个`executionContextObj`是在函数被调用的时候就已经创建完成了，同时这个过程要优先代码执行过程，可以被称为`creation Stage`.在这个过程中，js解释器通过搜索内部的形参，变量以及一些声明的函数，来创建出`executionContextObj`。而当解释器搜索完之后，得到的结果就是`variableObject`

#### 执行对象/变量对象(AO/VO)

> AO(执行对象)/变量对象(VO)，这两个概念在同一个执行上下文中，它们两者基本一致，两者的区别在于，如果函数不进入代码执行阶段，那么这个时候就叫做`VO`,如果进行到代码执行环境的时候，这个时候`VariableObject`就被叫做`AO(执行对象)`

#### 解释器执行代码过程的解析

1. 找到调用函数的代码，开始创建
2. 在正式执行代码前，首先创建`execution context`
3. 进入创建阶段：
   - 初始化`Scope Chain`
   - 创建`variable object`
     - 创建实参对象(`arguments object`)，检查`context`的形参(`parameters`)，初始化参数的名称和参数值并且创建一份引用的拷贝
     - 扫描context的函数拷贝
       - 为每个函数在`variable object`创建一个属性，属性名就是函数名，值就是指向内存中函数的引用指针
       - 如果当前声明的函数已经在`variable object`存在了那么就会覆盖这个对象内的函数
     - 扫描`context`中变量声明
       - 为每个变量在`variable object`上的创建一个属性，属性名就是变量名并且将变量的初始化为`undefined`
       - 如果变量名在`variable object`中已经存在，就会忽略这段变量声明
   - 确定context中的`this`的值
4. 代码激活/代码执行阶段

- 运行/解释`context`中的函数，并且根据一行一行的执行，为变量赋值



🌰

```
function foo(i){
	var a = 'hello';
	var b = function privateB(){
		
	}
	function c(){
	
	}
}

foo(10)
```

当调用`foo(10)`，创建阶段`(creation Stage)`时，`context`是下面这个样子

```
fooExecutionContext = {
	scopeChain:{...},
	variableObject:{
		arguments:{
			0:10,
			length:1
		},
		i:10,
		c: pointer to function(){},
		a: undefined,
		b: undefined
	}
	this: {...}
}
```

2. execution Stage（代码执行）阶段

```
fooExecutionContext = {
	scopeChain:{...},
	variableObject: {
	arguments:{
		0: 10,
		length: 1
	},
	i: 10,
	c: pointer to function(){},
	a:'hello',
	b: pointer to function(){}
	},
	this:{...}
}
```



### 作用域

> 都知道程序中存在着变量这个东西，但是：**变量要储存在什么地方？当程序需要的时候，又要从哪里才能找到这些变量**

- 所以需要一套规则来存储这些变量，并且能够使程序快速使用到这些变量，这套规则就叫做**作用域**---小黄书

- 作用域是指在程序中定义变量的区域，该位置决定了变量的周期。认真讲就是变量与函数的可访问性的范围，即作用域控制着变量和函数的可见性和生命周期

#### 编译原理

尽管js被归类成"动态"或者"解释性"语言，但事实上它是一门编译语言。传统的编译语言的流程中，程序中的一段源代码在执行之前一般要经历3个步骤：称为编译。

- 词法分析/分词
  	1. 该过程会将由字符组成的字符串分解成有意义的代码块。这些代码块被称为词法单元，如：var a = 2;就会被分成`var`、`a`、`2`,如果空格在当前语言中存在意义，那也要考虑进去。
- 语法分析/解析
  	2. 将第一步分解完的词法单元流（数组，第一步中的词法单元会形成一个数组），转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为抽象语法树（AST:Abstract Syntax Tree）.['var','a',2]转换成抽象语法树可能会有一个叫做`VaribaleDeclaration`的顶级节点，然后是`Indentifier(值是a)`的子节点，以及一个叫做`AssignmentExpression`的子节点。`AssignmentExpression`节点有一个叫做`NumbericLiter(他的值是2)`的子节点
- 代码生成
  3. 将AST转换成可执行代码的过程

#### 理解作用域的作用

1. 引擎 从头到尾负责整个JavaScript程序的编译及执行过程
2. 编译器 负责语法分析及代码分成
3. 作用域：**负责收集并维护所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限**

> 当遇到 `var a = 2`

事实上编译器会和作用域做以下处理

1. 遇到var a,编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略这个声明，继续进行编译；否则会要求在作用域的集合中声明一个变量，并命名为`a`
2. 然后编译器会为引擎生成运行的代码，这些代码被用来处理a=2这个赋值操作。引擎运行时会访问作用域，在作用域的集合中，是否存在这么一个变量`a`,如果是，引擎就会使用这个变量；反之，引擎继续查找这个变量



#### 作用域链

> 当一个块或函数嵌套在另一个块或者函数内时，就发生了作用域的嵌套。因此在当前作用域无法找到某个变量的时候，引擎就会在外层嵌套的作用域中查找，直到查找到这个变量，或者在全局作用域也没有找到这个变量，而这一系列的作用域连接起来之后，被称为作用域链

可以把作用域链比作楼房

> 当我们需要在这个楼房找一个人的时候，如果不出意外，那么需要从1楼的一个一个房间的找，直到找到这个楼层的阳台（全局作用域）

```
function parent(){
	var a = 2;
	function child(){
		var b = 2;
		console.log(a,b)
	}
	child();
	console.log(b)
}
parent();
```

1. 打印`a`和`b`首先在第一楼(当前作用域)找，发现了`b`的定义，然后再在当前作用域的查找是否存在变量`a`的定义，发现当前作用域没有`a`的定义
2. 就开始往2楼找(parent作用域)，查找当前作用域，发现`a`的定义。

#### 词法作用域

1. 静态作用域  函数作用域取决于函数定义的位置
2. 动态作用域  函数作用域取决于函数调用的位置

**确定词法作用域**

之前介绍过大部分的标准语言编译器的第一个工作阶段叫做`词法分析`。词法作用域就是定义在`词法阶段的作用域`，换句话说：词法作用域是由你在写代码时候将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码的时候会保持作用域不变

🌰

```
function foo(a){
	var b = a*2;
	function bar(c){
		console.log(a,b,c);
	}
	bar(b*3)
}
foo(2)  // 2,4,12;
```

分析一下这段代码所包含的作用域（注意标识符属于那个作用域，只跟当前变量的定义是在哪里定义的有关）

1. 包含着整个全局作用域，其中只有一个标识符：foo
2. 包含着foo所创建的作用域，其中有三个标识符：a,bar,b;
3. 包含着bar所创建的作用域，其中只有一个标识符：c;

**欺骗词法**

> 因为词法作用域完全由写代码期间函数定义的位置来决定的，怎么在`词法分析`阶段来`修改`词法作用域呢？

1. eval

> `eval`接收一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中的这个位置的代码
>
> 在执行`eval`之后的代码时，引擎并不知道或在意前面的代码是如何进来的，并对当前词法作用域发生改变。
>
> 引擎只会在词法作用域中查找变量（标识符）而已

🌰

```
function foo(str,a){
eval(str);
console.log(a,b);
}
var b = 3;
foo("var b=2",1) // 1,2
```

在`严格模式`中，已经禁止了这样修改当前词法作用域的行为。

1. with

> With 可以将一个没有属性或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域的词法标识符

但是`with`的使用会带来不好的结果

 ```
function foo(obj){
	with(obj){
		a = 2;
	}
}
var o1 = {
a:3
}
var o2 = {
b:1
}
foo(o1);
console.log(o1.a) //2
foo(o2)
console.log(o2.a) // undefined
console.log(a) // 2
 ```

> 如果当对象里面没有`a`的时候，他就会在全局对象中创建一个属性`a`

#### 函数作用域

> 定义在函数中的作用域，用来收集函数内的标识符，管理这些标识符的行为和访问权限

1. 函数表达式

2. 函数定义

   - 匿名函数
     - 匿名函数在栈的追踪的时候，没有办法使用一个有意义的函数名，这样使得当前函数的调试的困难程度会加大。
     - 如果没有函数名，当函数需要引用自身时只能使用已经过期的`arguments.callee`引用。
     - 匿名函数省略了对代码可读性/可理解性很重要的函数。一个描述性的名称可以让代码不言自明。
   - 具名函数
   - 立即执行函数

   ```
   var a = 2;
   (function foo(){
   	console.log(a) //2
   }())
   ```

3. 构造函数

#### 块作用域

> 块作用域时一个用来对之前最小授权原则进行扩展的工具，将代码从函数中隐藏信息扩展为在块中隐藏信息

> 大部分的语言都支持块级作用域。块级作用域就是使用一对花括号`{}`包括了一块区域型的代码

常见的块级作用域

```
if(/*expression*/){/*expression*/}
while(/*expression*/){/*expression*/}
function(/*variable*/){/*expression*/}
for(;;){/expression/}
{}
```

一门语言如果支持块级作用域，那么在块级作用域里面定义的任何变量，都是无法在外部获取到的

🌰

```
for(var i=0;i<5;i++){
	console.log*(i)
}
console.log(i) // 5

while(true){
var a = 5;
}
console.log(a) //5
{
	var b = 6;
}
console.log(b) // 6;
```

**其实在大部分的js的代码时不支持块级作用域的写法的**

**现在js所支持的块级作用域**

1. with

```
用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效
```

2. try-catch

> catch分局会创建一个块作用域，其中声明的变量仅在catch内部有效

```
try{
	undefined();
}catch(err){
	console.log(err)
}
console.log(err)
```

3. let

> let 关键字可以将变量绑定到所在的任意关键字（通常是{...}内部）。换句话说，let为其声明变量隐式地劫持了所在的块作用域。

```
var foo = true;
if(foo){<---显式的块
	let bar = foo*2;
	bar = something(bar);
	console.log(bar);
}<---显式的块
console.log(bar); // ReferenceError
```

4. const

> 一旦定义了值了之后，值的本身不能发生改变，但是当值是一个对象的时候，他的标识符一开始指向的是一个地址，其实在这个地址不改变的情况下，在不改变地址的情况下，是可以对当前对象进行改变的，可以对对象内部的值进行增加删除和修改、

```
const obj1 = {a:1};
obj1.a = 2;
console.log(obj1)// {a:2}
obj1.b = 1;
console.log(obj1) // {a:2,b:1}
```

----

**理解let和const实现对块级作用域的支持**

1. 通过执行上下文来了解

```
function foo(){
	var a = 1;
	let b = 2;
	if(true){
		let b = 3;
		var c = 4;
		let d = 5;
		console.log(a)
		console.log(b)
	}
	console.log(b);
	console.log(c);
	console.log(d);
}
foo();
```

1. 首先js引擎会先进行编译并创建执行上下文。

![](https://github.com/4lQuiorrA/frontEnd-base/blob/master/image/kuaijizuoyongyu.png)

- 开始执行`foo`函数,可以知道函数内部通过`var`声明的变量，在编译的阶段全部被存放到了变量环境中
- 通过`let`声明的变量被存放到了**词法环境**中
- 最重要的一点，在函数体内部的块级作用域内部`let`声明的变量并没有被立即存放到**词法环境**中

1. 然后按照顺序执行

![](https://github.com/4lQuiorrA/frontEnd-base/blob/master/image/kuaijizuoyongyu1.png)

- 当执行到块级作用域的时候，`foo`中的`a,b`已经被赋值好了
- 然后将继续将块级作用域中的`b,d`放入属于他们自己的词法环境中
- 然后完成对`b、c、d`的赋值操作

可以看出，在**词法环境**中，其实是维护了一个栈的内容，用来存放不同作用域的内容，保留先进后出的原则，所以栈底的内容就是最外层作用域的用`let`声明的变量。当激活这个作用域的时候，就会将这个块作用域压入整个词法环境栈中（类似函数的执行过程），当执行完之后，就会将该块级作用域从栈中释放，同时销毁在这个块级作用域中定义的变量：指`let`和`const`声明的。

当开始从作用域取值的时候，也会像作用域链机制一样，去寻找变量。如果没找到，就会继续在**词法环境**中寻找，如果在词法环境中没有找到，那么就会进入**变量环境**中寻找，找到就返回，没有找到就返回`ReferenceError`

