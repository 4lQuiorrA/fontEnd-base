### 模式匹配
Javascript定义RegExp()构造函数，用来创建表示文本匹配模式的对象。
RegExp的定义有2种方法
1. 直接量语法
```
/pattern/attributes
```
2. 构造函数

```
new RegExp(pattern,attributes)
```

    - 参数pattern是一个字符串，指定了正则表达式的模式或者其他正则表达式
    - 参数attributes是一个可选的字符串，包含属性是`i,m,g`,区分大小写的匹配，多行匹配，全局匹配

修饰符
```
i 执行对da xia大小写不敏感的匹配
g 执行全局匹配（查找所有匹配的而非在找到第一个匹配后就停止了）
m 执行多行匹配
```


**. (点号，小数点)匹配是任意单个字符，但是行结束符除外：\n\r\u2028或\u2029**
如：
```
/.y/ 匹配“yes make my day” 会匹配"my" "ay"
```

**\d匹配任意的阿拉伯数字等价于[0-9]，个人猜想\d是指digit（十进制）的意思**
如：
```
/\d/匹配"B2 is the suite number"中的2
```

**\D匹配任意不是阿拉伯数字等价于[^0-9]**
如：
```
/\D/匹配“1231abc” 中的“abc”
```
**\w匹配任意来自基本拉丁字母表的中字母数字字符，还包含下划线。等价于[0-9a-zA-Z_]**
```
/\w/匹配"apple"中的'a','$5.28'中的'5'和'3D'中的'3'
```
**\W匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。等价于[^A-Za-z0-9_]**
```
/W或/[^A-Za-z0-9]/匹配“50%”中的“%”
```
**\s匹配一个空白符，包括空格、制表符、换页符、换行符和其他Unicode空格**
```
/\s\w*/ 匹配“foo bar”中的“ bar”
```

**\S匹配一个非空白符**
```
/\S\w*/ 匹配“foo bar”中的“foo”
```

**\t匹配一个水平制表符**

**\r匹配一个回车符**

### 字符集合

**[xyz]一个字符集合，也叫字符组。匹配集合中的任意一个字符。你可以使用连字符‘-’指定一个范围**

**[^xyz]一个反义或补充字符集，也叫反义字符组**

### 边界

**^匹配输入开始处，如果多行（multiple）标志设为true,该字符也会匹配一个断行（line break）符后的好处**

```
/^A/

/\w\n/
/\d\s/
第二行的正则会根据第一行的匹配情况是true还是false
```

**$匹配输入结尾。**
```
/t$/匹配以t结尾的内容，如“eater”中的"t",但是会匹配"eat"中的“t”
```

**\b 匹配一个零宽单词边界**

这句话MDN上的原画
w3c:**在单词边界匹配的位置，单词字符后面或前面不与另一个单词字符直接相邻。请注意，匹配的单词边界并不包含在匹配中。换句话说，匹配的单词边界的长度为零。**
例子🌰：
```
/\bm/匹配“moon”上的m
/oo\b/不匹配“moon”中的"oo",因为“oo”后面的'n'是一个单词，长度不为0
/oo\b/匹配“moon”中的“oon”,因为“oon”位于字符串的末端，后面没有单词字符
```

**\B匹配一个零宽非单词边界**


#### 数量词

**'x*'匹配前面的模式x,0到多次**

例子🌰：
```
/bo*/匹配 "A ghost booooed"中的'boooo','A bird warbled'中的'b',但是不匹配"A goat grunted"
```
因为`/bo*/`可以让`o`0次或者多次出现

**'x+'匹配前面的模式x，1到多次，等价{1,}**

例子🌰：
```
/b+/ 匹配'bbbboooo'中的'bbbb'，同时也匹配'bo'，但是不匹配 'A ghost'

```
因为`/b+/`匹配`b`里面的1到多次，**记住必须要大于等于一**

**'a?' 匹配前面的模式a，1次或0次**
距离

```
/a?/.test("test")  // true
/a?/.test("apple") // false 
```
----
将`+,*`与`?`结合之后
会匹配当前数量词的最小值，什么意思呢？
就是`+`是最小是匹配1个
`*`匹配的最小的是0个

![](https://github.com/4lQuiorrA/frontEnd-base.git)