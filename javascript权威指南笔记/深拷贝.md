### 序列化对象

**序列化的方法实现深拷贝不安全**
> JSON对象的语法是JavaScript语法的自己，它并不能代表JavaScript里的所有的值。JSON支持对象、数组、字符串、数字、true、false和null，并且它们可以序列化和还原。NaN和Infinity和-Infinity序列化的结果是null，日期对象序列化的结果ISO类型的日期字符串，但是JSON.parse依然保留它们字符串形态，而不会将它们还原成原始日期对象。函数，RegExp，Error对象和undefined值不能序列化和还原。JSON.stringify只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串会将这个属性省略掉。JSON.stringify和JSON.parse都可以接受第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。
```
// NaN的序列化
var a = {
b:NaN
}

var c = JSON.parse(JSON.stringify(a))
console.log(c) // {b:null}

// Infinity 和-Infinity 正无穷大和负无穷大
var a = {
    b:Infinity
}
var c = JSON.parse(JSON.stringify(a))
console.log(c) // {b:null}

// 日期对象
var a = {
b:new Date()

}
var c = JSON.parse(JSON.stringify(a))

console.log(c)

// {b: "2019-11-26T15:10:18.548Z"} 并不能直接转换成对象，而是被转换成了字符串

// 函数,undefined,RegExp
var a = {
b:function(){
console.log(this)
},
d:undefined,
e: /\w+/,
f: new Error(),
}

var c = JSON.parse(JSON.stringify(a))

console.log(c)
// {e: {…}, f: {…}}  
由于无法序列化这几个内容，其中函数和undefined直接被忽略掉，正则和Error被序列化成为了空json

// 不可枚举的值
var a = {
b:1,
}

Object.defineProperty(a,"c",{
value:2,
enumerable: false
})

console.log(a)

var c = JSON.parse(JSON.stringify(a))

console.log(c) // {b:1}
```